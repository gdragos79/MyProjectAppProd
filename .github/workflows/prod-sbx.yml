name: PROD SBX (blue/green deploy -> flip proxy -> soak -> rollback)

on:
  workflow_dispatch:
    inputs:
      IMAGE_TAG_BASE:
        description: "Base tag from Staging (e.g. 01_11_2025_v0.8_restructure-monorepo). We'll pull prod-candidate_<tag> from GHCR."
        type: string
        required: true
      TARGET_OVERRIDE:
        description: "Force deploy to a color (otherwise auto-picks the inactive color)"
        type: choice
        default: auto
        options: [auto, blue, green]
      SOAK_SECONDS:
        description: "Soak time after flip (seconds, default 600 = 10 minutes)"
        type: number
        default: 600

concurrency:
  group: production-deploy
  cancel-in-progress: false

permissions:
  contents: read
  packages: read   # pull from GHCR with GITHUB_TOKEN

env:
  REGISTRY: ghcr.io
  PROD_PORT: "3000"   # backend listens on 3000 on Blue/Green; proxy forwards to the active VM:3000
  ACTIVE_LINK: /etc/nginx/upstreams/active.conf
  BLUE_CONF:  /etc/nginx/upstreams-available/upstream-blue.conf
  GREEN_CONF: /etc/nginx/upstreams-available/upstream-green.conf

jobs:
  resolve_image:
    if: github.ref_name == 'restructure/monorepo'
    runs-on: ubuntu-latest
    outputs:
      IMAGE_PULL: ${{ steps.meta.outputs.IMAGE_PULL }}
      BASE_TAG:   ${{ steps.meta.outputs.BASE_TAG }}
    steps:
      - name: Compute image reference
        id: meta
        shell: bash
        run: |
          set -euo pipefail
          OWNER="${GITHUB_REPOSITORY%/*}"
          REPO="${GITHUB_REPOSITORY#*/}"
          OWNER_LC=$(echo "$OWNER" | tr '[:upper:]' '[:lower:]')
          REPO_LC=$(echo "$REPO" | tr '[:upper:]' '[:lower:]')
          BASE="${{ inputs.IMAGE_TAG_BASE }}"
          IMAGE_PULL="${{ env.REGISTRY }}/${OWNER_LC}/${REPO_LC}-backend:prod-candidate_${BASE}"
          echo "IMAGE_PULL=$IMAGE_PULL" >> "$GITHUB_OUTPUT"
          echo "BASE_TAG=$BASE"        >> "$GITHUB_OUTPUT"
          echo "Will pull: $IMAGE_PULL"

      - name: Login to GHCR (for pull test)
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Validate image exists
        shell: bash
        run: |
          set -euo pipefail
          docker pull "${{ steps.meta.outputs.IMAGE_PULL }}"
          echo "✅ Image is present in GHCR."

  pick_target:
    if: github.ref_name == 'restructure/monorepo'
    needs: resolve_image
    runs-on:
      labels:
        - self-hosted
        - proxy
    outputs:
      active_color: ${{ steps.pick.outputs.active_color }}
      target_color: ${{ steps.pick.outputs.target_color }}
      target_label: ${{ steps.pick.outputs.target_label }}
    steps:
      - name: Detect active color (proxy)
        id: pick
        shell: bash
        run: |
          set -euo pipefail
          ACTIVE_LINK="${{ env.ACTIVE_LINK }}"
          BLUE_CONF="${{ env.BLUE_CONF }}"
          GREEN_CONF="${{ env.GREEN_CONF }}"

          CUR=$(readlink -f "$ACTIVE_LINK" || true)
          if [[ "$CUR" == "$BLUE_CONF" ]] || echo "$CUR" | grep -qi "blue"; then
            ACTIVE=blue
          elif [[ "$CUR" == "$GREEN_CONF" ]] || echo "$CUR" | grep -qi "green"; then
            ACTIVE=green
          else
            echo "::warning::Could not infer active color from $ACTIVE_LINK ($CUR). Defaulting ACTIVE=blue."
            ACTIVE=blue
          fi

          OVERRIDE="${{ inputs.TARGET_OVERRIDE }}"
          if [[ "$OVERRIDE" == "blue" || "$OVERRIDE" == "green" ]]; then
            TARGET="$OVERRIDE"
          else
            if [[ "$ACTIVE" == "blue" ]]; then TARGET="green"; else TARGET="blue"; fi
          fi

          echo "Active: $ACTIVE"
          echo "Target: $TARGET (override=${OVERRIDE})"

          echo "active_color=$ACTIVE" >> "$GITHUB_OUTPUT"
          echo "target_color=$TARGET" >> "$GITHUB_OUTPUT"
          echo "target_label=$TARGET" >> "$GITHUB_OUTPUT"

  deploy_to_target:
    if: github.ref_name == 'restructure/monorepo'
    needs: [resolve_image, pick_target]
    runs-on:
      labels:
        - self-hosted
        - ${{ needs.pick_target.outputs.target_label }}
    environment: Production
    steps:
      - name: Show runner info
        shell: bash
        run: |
          set -euo pipefail
          echo "Runner: $(hostname) / $(uname -a)"
          docker --version || true
          which docker || true
          which curl || (sudo apt-get update -y && sudo apt-get install -y curl)

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull image
        shell: bash
        env:
          IMAGE: ${{ needs.resolve_image.outputs.IMAGE_PULL }}
        run: |
          set -euo pipefail
          docker pull "$IMAGE"

      - name: Free host port ${{ env.PROD_PORT }} if used
        shell: bash
        run: |
          set -euo pipefail
          CIDS=$(docker ps -q --filter "publish=${{ env.PROD_PORT }}")
          if [ -n "$CIDS" ]; then
            echo "Port ${{ env.PROD_PORT }} is in use by container(s): $CIDS — stopping…"
            docker rm -f $CIDS || true
          fi
          if ss -ltnp | grep -q ":${{ env.PROD_PORT }} "; then
            echo "❌ Port ${{ env.PROD_PORT }} still busy (non-Docker process):"
            ss -ltnp | grep ":${{ env.PROD_PORT }} " || true
            exit 1
          fi

      - name: Remove old prod containers (optional cleanup)
        shell: bash
        run: |
          set -euo pipefail
          OLD=$(docker ps -a --filter "name=^prodContainer_" -q)
          if [ -n "$OLD" ]; then
            echo "Removing old prod containers: $OLD"
            docker rm -f $OLD || true
          fi

      - name: Run new container (host ${{ env.PROD_PORT }} -> container 3000)
        shell: bash
        env:
          IMAGE:   ${{ needs.resolve_image.outputs.IMAGE_PULL }}
          BASE:    ${{ needs.resolve_image.outputs.BASE_TAG }}
          DB_HOST: ${{ secrets.DB_HOST }}
          DB_PORT: ${{ secrets.DB_PORT }}
          DB_USER: ${{ secrets.DB_USER }}
          DB_PASS: ${{ secrets.DB_PASSWORD }}
          DB_NAME: ${{ secrets.DB_NAME }}
        run: |
          set -euo pipefail
          NAME="prodContainer_${BASE}"
          docker run -d --name "$NAME" \
            --label app=prod-backend \
            -e DB_HOST="$DB_HOST" \
            -e DB_PORT="$DB_PORT" \
            -e DB_USER="$DB_USER" \
            -e DB_PASSWORD="$DB_PASS" \
            -e DB_NAME="$DB_NAME" \
            -e PORT="3000" \
            -p ${PROD_PORT}:3000 \
            "$IMAGE"
          echo "Started: $NAME"
          docker ps --filter "name=$NAME"

      - name: Local health check on target VM (pre-flip)
        shell: bash
        run: |
          set -euo pipefail
          for i in {1..120}; do
            if curl -fsS "http://127.0.0.1:${PROD_PORT}/api/health" >/dev/null 2>&1; then
              echo "✅ Target VM backend healthy (pre-flip)."
              exit 0
            fi
            sleep 2
          done
          echo "❌ Target VM backend did not become healthy before flip."
          docker logs --tail=200 $(docker ps -q --filter "label=app=prod-backend") || true
          exit 1

  flip_proxy_and_soak:
    if: github.ref_name == 'restructure/monorepo'
    needs: [resolve_image, pick_target, deploy_to_target]
    runs-on:
      labels:
        - self-hosted
        - proxy
    environment: Production
    steps:
      - name: Flip active.conf to target color and reload Nginx
        id: flip
        shell: bash
        env:
          TARGET: ${{ needs.pick_target.outputs.target_color }}
          ACTIVE: ${{ needs.pick_target.outputs.active_color }}
        run: |
          set -euo pipefail
          ACTIVE_LINK="${{ env.ACTIVE_LINK }}"
          BLUE_CONF="${{ env.BLUE_CONF }}"
          GREEN_CONF="${{ env.GREEN_CONF }}"

          PREV=$(readlink -f "$ACTIVE_LINK" || true)
          echo "Previous active symlink target: $PREV"

          if [[ "$TARGET" == "blue" ]]; then NEW="$BLUE_CONF"; else NEW="$GREEN_CONF"; fi

          echo "Switching active to: $TARGET  ($NEW)"
          sudo ln -sfn "$NEW" "$ACTIVE_LINK"
          sudo nginx -t
          sudo systemctl reload nginx

          echo "prev_target=$PREV" >> "$GITHUB_OUTPUT"
          echo "new_target=$NEW"  >> "$GITHUB_OUTPUT"

      - name: Immediate proxy health check
        shell: bash
        run: |
          set -euo pipefail
          for i in {1..60}; do
            if curl -fsS "http://127.0.0.1/api/health" >/dev/null 2>&1; then
              echo "✅ Proxy -> backend health OK after flip."
              exit 0
            fi
            sleep 2
          done
          echo "❌ Proxy health failed right after flip."
          exit 1

      - name: Soak and re-check via proxy (auto-rollback on failure)
        shell: bash
        env:
          SOAK: ${{ inputs.SOAK_SECONDS }}
        run: |
          set -euo pipefail
          REM=$SOAK
          echo "Soaking for $REM seconds with health sampling…"
          while [ "$REM" -gt 0 ]; do
            if ! curl -fsS "http://127.0.0.1/api/health" >/dev/null 2>&1; then
              echo "❌ Health failed during soak. Rolling back…"
              exit 42
            fi
            sleep 15
            REM=$((REM-15))
          done
          echo "✅ Soak complete; health OK."

      - name: Rollback (if soak failed)
        if: failure()
        shell: bash
        env:
          PREV: ${{ steps.flip.outputs.prev_target }}
        run: |
          set -euo pipefail
          if [ -n "$PREV" ] && [ -e "$PREV" ]; then
            echo "Restoring previous active symlink to: $PREV"
            sudo ln -sfn "$PREV" "${{ env.ACTIVE_LINK }}"
            sudo nginx -t
            sudo systemctl reload nginx
          else
            echo "::warning::No previous target recorded; cannot rollback symlink."
          fi
          exit 1
