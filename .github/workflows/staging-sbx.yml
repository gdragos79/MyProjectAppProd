name: STG SBX (build → push → deploy on self-hosted → health → promote tag)

on:
  workflow_dispatch:

permissions:
  contents: read
  packages: write

env:
  APP_DIR: apps/backend
  REGISTRY: ghcr.io

jobs:
  build_and_push:
    # Build on GitHub-hosted runner, only from your test branch
    if: github.ref_name == 'restructure/monorepo'
    runs-on: ubuntu-latest

    outputs:
      TAG: ${{ steps.meta.outputs.TAG }}
      IMAGE_B: ${{ steps.meta.outputs.IMAGE_B }}
      IMAGE_B_PROD: ${{ steps.meta.outputs.IMAGE_B_PROD }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Compute image names and tag
        id: meta
        shell: bash
        run: |
          set -euo pipefail
          DATE=$(date +%d_%m_%Y)
          # Version increases by 0.1 per run of THIS workflow
          VRAW=$(awk -v n="$GITHUB_RUN_NUMBER" 'BEGIN{printf "%.1f", n/10}')
          VERSION="v${VRAW}"
          BRANCH_SAFE="${GITHUB_REF_NAME//\//-}"

          OWNER="${GITHUB_REPOSITORY%/*}"
          REPO="${GITHUB_REPOSITORY#*/}"
          OWNER_LC=$(echo "$OWNER" | tr '[:upper:]' '[:lower:]')
          REPO_LC=$(echo "$REPO" | tr '[:upper:]' '[:lower:]')

          TAG="${DATE}_${VERSION}_${BRANCH_SAFE}"
          IMAGE_B="${REGISTRY}/${OWNER_LC}/${REPO_LC}-backend:${TAG}"
          IMAGE_B_PROD="${REGISTRY}/${OWNER_LC}/${REPO_LC}-backend:prod-candidate_${TAG}"

          {
            echo "TAG=$TAG"
            echo "IMAGE_B=$IMAGE_B"
            echo "IMAGE_B_PROD=$IMAGE_B_PROD"
          } >> "$GITHUB_OUTPUT"

          echo "Computed:"
          echo "  TAG=$TAG"
          echo "  IMAGE_B=$IMAGE_B"
          echo "  IMAGE_B_PROD=$IMAGE_B_PROD"

      - name: Login to GHCR (runner)
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build & Push backend image
        working-directory: ${{ env.APP_DIR }}
        shell: bash
        run: |
          set -euo pipefail
          docker buildx create --use --name xbuilder || docker buildx use xbuilder
          docker buildx build \
            -f Dockerfile \
            -t "${{ steps.meta.outputs.IMAGE_B }}" \
            --push \
            .

      - name: Promote to prod-candidate tag (registry only; no deploy)
        shell: bash
        run: |
          set -euo pipefail
          docker pull "${{ steps.meta.outputs.IMAGE_B }}"
          docker tag  "${{ steps.meta.outputs.IMAGE_B }}" "${{ steps.meta.outputs.IMAGE_B_PROD }}"
          docker push "${{ steps.meta.outputs.IMAGE_B_PROD }}"

  deploy_to_staging:
    # Deploy on your Staging VM via a self-hosted runner (label it: staging)
    if: github.ref_name == 'restructure/monorepo'
    needs: build_and_push
    runs-on: [self-hosted, staging]
    environment: Staging

    steps:
      - name: Show runner info (self-hosted)
        shell: bash
        run: |
          set -euo pipefail
          echo "Runner: $(hostname) / $(uname -a)"
          docker --version || true
          which docker || true
          which curl || (sudo apt-get update -y && sudo apt-get install -y curl)

      - name: Login to GHCR (self-hosted runner)
        # Uses the job's GITHUB_TOKEN; works for pulling images of this repo
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull image
        shell: bash
        run: |
          set -euo pipefail
          docker pull "${{ needs.build_and_push.outputs.IMAGE_B }}"

      - name: Stop old container (if any)
        shell: bash
        env:
          TAG: ${{ needs.build_and_push.outputs.TAG }}
        run: |
          set -euo pipefail
          NAME="stgContainer_${TAG}"
          docker rm -f "$NAME" 2>/dev/null || true

      - name: Run new container (host 3001 → container 3000)
        shell: bash
        env:
          IMAGE_B: ${{ needs.build_and_push.outputs.IMAGE_B }}
          TAG:     ${{ needs.build_and_push.outputs.TAG }}
          DB_HOST: ${{ secrets.DB_HOST_STAGING }}
          DB_PORT: ${{ secrets.DB_PORT_STAGING }}
          DB_USER: ${{ secrets.DB_USER_STAGING }}
          DB_PASS: ${{ secrets.DB_PASSWORD_STAGING }}
          DB_NAME: ${{ secrets.DB_NAME_STAGING }}
        run: |
          set -euo pipefail
          NAME="stgContainer_${TAG}"
          docker run -d --name "$NAME" \
            -e DB_HOST="$DB_HOST" \
            -e DB_PORT="$DB_PORT" \
            -e DB_USER="$DB_USER" \
            -e DB_PASSWORD="$DB_PASS" \
            -e DB_NAME="$DB_NAME" \
            -e PORT="3000" \
            -p 3001:3000 \
            "$IMAGE_B"

      - name: Health check /api/health on 127.0.0.1:3001
        shell: bash
        env:
          TAG: ${{ needs.build_and_push.outputs.TAG }}
        run: |
          set -euo pipefail
          NAME="stgContainer_${TAG}"
          for i in {1..60}; do
            if curl -fsS "http://127.0.0.1:3001/api/health" >/dev/null 2>&1; then
              echo "✅ Staging health OK at /api/health (port 3001)"
              docker ps --filter "name=$NAME"
              exit 0
            fi
            sleep 2
          done

          echo "❌ Staging health failed. Recent logs:"
          docker logs --tail=200 "$NAME" || true
          exit 1
